# -*- coding: utf-8 -*-
"""BIO213.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18ke5SlWGBEXP3RhdtxIHAoO7CHAHdx3L
"""

str1 = input("Enter the sequence: ") #MVVTPVTAYGPNHAGNFK----G-----MKVWALVKEKGAV--------KVDEVGGEALGRLLVVYPWTQRFFESFGDLSTPDAVMGNPKVKAHGKKVLGAFSDGL
str2 = input("Enter another sequence: ") #MALWM------RLLPLLALLALWGPDPAAAFVNQHLCGSHLVEALYLVCGERGFFYTPKT---------REE-------VQKRGIVEQCCTSICSLYQLENYCNAH

if(len(str1) != len(str2)):
  raise ValueError("Input sequences must have the same length")

length = len(str1)
empty_places = []
def compare_strings(str1, str2):
  i = 0
  while i < length:
    if str1[i] == '-' or str2[i] == '-':
      empty_places.append(i)
    i += 1
  return empty_places

if(len(str1) != len(str2)):
  raise ValueError("Input sequences must have the same length")

length = len(str1)
def count_match_gaps(seq1, seq2):
  match = 0
  gaps = 0

  for i in range(length):
    if(seq1[i] == seq2[i]):
      match +=1
    else:
      if(seq1[i] == "-" or seq2[i] == "-"):
        gaps +=1
  return match, gaps

match, gaps = count_match_gaps(str1,str2)

print("Number of matches: ", match)
print("Number of gaps: ", gaps)
print(compare_strings(str1,str2))

similar_amino_acids = {
    'A': ['G', 'V'],        # Alanine can be substituted with Glycine or Valine.
    'S': ['T', 'C'],        # Serine can be substituted with Threonine or Cysteine.
    'T': ['S', 'V', 'I'],   # Threonine can be substituted with Serine, Valine, or Isoleucine.
    'V': ['A', 'I', 'L', 'T'],  # Valine can be substituted with Alanine, Isoleucine, Leucine, or Threonine.
    'I': ['V', 'L', 'T', 'M'],  # Isoleucine can be substituted with Valine, Leucine, Threonine, or Methionine.
    'L': ['V', 'I', 'M'],   # Leucine can be substituted with Valine, Isoleucine, or Methionine.
    'F': ['Y', 'W'],        # Phenylalanine can be substituted with Tyrosine or Tryptophan.
    'Y': ['F', 'W'],        # Tyrosine can be substituted with Phenylalanine or Tryptophan.
    'D': ['E', 'N'],        # Aspartic Acid can be substituted with Glutamic Acid or Asparagine.
    'E': ['D', 'Q'],        # Glutamic Acid can be substituted with Aspartic Acid or Glutamine.
    'K': ['R'],             # Lysine can be substituted with Arginine.
    'R': ['K'],             # Arginine can be substituted with Lysine.
    'N': ['D', 'Q'],        # Asparagine can be substituted with Aspartic Acid or Glutamine.
    'Q': ['E', 'N'],        # Glutamine can be substituted with Glutamic Acid or Asparagine.
    'M': ['I', 'L'],        # Methionine can be substituted with Isoleucine or Leucine.
    'H': ['Q'],             # Histidine can be substituted with Glutamine.
    'C': ['S'],             # Cysteine can be substituted with Serine.
    'W': ['Y', 'F']         # Tryptophan can be substituted with Tyrosine or Phenylalanine.
}

def count_similar_amino_acids(align1, align2, similar_amino_acids):
    if len(align1) != len(align2):
        raise ValueError("The alignment lengths must be the same")

    similar_count = 0

    for aa1, aa2 in zip(align1, align2):
        if aa1 in similar_amino_acids and aa2 in similar_amino_acids[aa1]:
            similar_count += 1

    return similar_count

def calculate_similarity_percentage(align1, align2, similar_amino_acids):
    if len(align1) != len(align2):
        raise ValueError("The alignment lengths must be the same")

    similar_count = count_similar_amino_acids(align1, align2, similar_amino_acids)
    total_amino_acids = len(align1)

    similarity_percentage = (similar_count / total_amino_acids) * 100
    return similarity_percentage

def print_similarity_table(align1, align2, similar_amino_acids):
    if len(align1) != len(align2):
        raise ValueError("The alignment lengths must be the same")

    print("Position\tQuery \t\tSubject \tSimilarity")
    print("--------------------------------------------")

    for i, (aa1, aa2) in enumerate(zip(align1, align2), start=1):
        if ((aa1 in similar_amino_acids and aa2 in similar_amino_acids[aa1]) or aa1 == aa2):
          similarity = "Similar"
        else:
          similarity = "Different"
        print(f"{i}\t\t{aa1}\t\t{aa2}\t\t{similarity}")


# Example
sequence1 = input("Enter the First Sequence: ")  #"ATGCRNQTCQM"
sequence2 = input("Enter the Second Sequence: ") #"VTGSQEYYESL"

print_similarity_table(sequence1, sequence2, similar_amino_acids)

similarity_percentage = calculate_similarity_percentage(sequence1, sequence2, similar_amino_acids)
print(f"Similarity Percentage: {similarity_percentage}%")

# BIO
radius = int(input("Enter the input: "))

area_circle = (22 * radius * radius)/7
area_semicircle = (22 * radius * radius)/14

print("Area of Circle: ", area_circle)
print("Area of Semi Circle: ", area_semicircle)

original_number = float(input("Enter the number: "))

number_as_string = str(original_number)

number_as_float = float(original_number)

print("Original number: ", original_number)
print("Number as String: ", number_as_string)
print("Number as Float: ", number_as_float)

list = []

num = int(input("Enter the elements: "))

for i in range(0,num):
  element = int(input())
  list.append(element)

def sort(list, asc = True):
  if asc:
    list.sort()
  else:
    list.sort(reverse = True)
  return list

max_element = list[0]

for num in list:
    if num > max_element:
        max_element = num

sum = 0
for i in range(0,len(list)):
  sum += list[i]

mean = sum/len(list)

print("Ascending: ", sort(list, True))
print("Descending: ", sort(list, False))
print("Largest Element: ", max_element)
print("Mean Value: ", mean)

# def sort(list, asc):
#   if(asc == True):
#     i = 0; j = len(list)-1
#     while(i<=j):
#       if(list[i] < list[j]):
#         (list[i], list[j]) = (list[j], list[i])
#         i += 1
#       else:
#         j -= 1
#   return list

import math

# Amino acids
amino_acids = "ARNDCQEGHILKMFPSTWYV"

# Initialize a dictionary to store amino acid occurrences
aa_counts = {aa: 0 for aa in amino_acids}

# List of aligned sequences
aligned_sequences = [
    "DSDQQD",
    "DSSQQD",
    "SSQQDD",
    "DDQQDD"
]

# Count amino acid occurrences
total_aa_count = 0
for seq in aligned_sequences:
    for aa in seq:
        if aa in amino_acids:
            aa_counts[aa] += 1
            total_aa_count += 1

# Calculate amino acid probabilities
aa_probabilities = {aa: count / total_aa_count for aa, count in aa_counts.items()}

# Initialize a substitution matrix
substitution_matrix = {}

# Calculate observed substitution probabilities
for i in range(len(amino_acids)):
    for j in range(len(amino_acids)):
        aa_i = amino_acids[i]
        aa_j = amino_acids[j]
        pair_count = 0

        for seq in aligned_sequences:
            if aa_i in seq and aa_j in seq:
                pair_count += 1

        if pair_count > 0:
            observed_prob = pair_count / total_aa_count
            substitution_matrix[(aa_i, aa_j)] = observed_prob / (aa_probabilities[aa_i] * aa_probabilities[aa_j])

# Calculate BLOSUM scores
scaling_factor = 10  # BLOSUM scaling factor
blosum_matrix = {}

for pair, observed_prob in substitution_matrix.items():
    blosum_score = round(math.log2(observed_prob) * scaling_factor)
    blosum_matrix[pair] = blosum_score

# Print the BLOSUM 60 substitution matrix
for i in range(len(amino_acids)):
    for j in range(len(amino_acids)):
        aa_i = amino_acids[i]
        aa_j = amino_acids[j]
        print(f"{aa_i}{aa_j}: {blosum_matrix.get((aa_i, aa_j), 0)}", end="\t")
    print()

def needleman_wunsch(seq1, seq2, match_score=5, mismatch_score=-2, gap_penalty=-5):
    # Initialize the scoring matrix
    rows, cols = len(seq1) + 1, len(seq2) + 1
    score_matrix = [[0 for _ in range(cols)] for _ in range(rows)]

    # Initialize the traceback matrix
    traceback_matrix = [[0 for _ in range(cols)] for _ in range(rows)]

    # Initialize the first row and column of the scoring matrix
    for i in range(rows):
        score_matrix[i][0] = i * gap_penalty
        traceback_matrix[i][0] = 'U'
    for j in range(cols):
        score_matrix[0][j] = j * gap_penalty
        traceback_matrix[0][j] = 'L'

    # Fill in the scoring matrix
    for i in range(1, rows):
        for j in range(1, cols):
            match = score_matrix[i - 1][j - 1] + (match_score if seq1[i - 1] == seq2[j - 1] else mismatch_score)
            delete = score_matrix[i - 1][j] + gap_penalty
            insert = score_matrix[i][j - 1] + gap_penalty
            score_matrix[i][j] = max(match, delete, insert)

            if score_matrix[i][j] == match:
                traceback_matrix[i][j] = 'D'  # Diagonal
            elif score_matrix[i][j] == delete:
                traceback_matrix[i][j] = 'U'  # Up
            else:
                traceback_matrix[i][j] = 'L'  # Left

    # Traceback to find the alignment
    alignment1 = []
    alignment2 = []
    i, j = rows - 1, cols - 1
    while i > 0 or j > 0:
        if traceback_matrix[i][j] == 'D':
            alignment1.append(seq1[i - 1])
            alignment2.append(seq2[j - 1])
            i -= 1
            j -= 1
        elif traceback_matrix[i][j] == 'U':
            alignment1.append(seq1[i - 1])
            alignment2.append('-')
            i -= 1
        else:
            alignment1.append('-')
            alignment2.append(seq2[j - 1])
            j -= 1

    alignment1.reverse()
    alignment2.reverse()

    return ''.join(alignment1), ''.join(alignment2), score_matrix[rows - 1][cols - 1]


seq1 = "AGTACGCA"
seq2 = "TATGC"
alignment1, alignment2, score = needleman_wunsch(seq1, seq2)
print("Alignment 1:", alignment1)
print("Alignment 2:", alignment2)
print("Alignment Score:", score)

pip install biopython

from Bio import SeqIO, AlignIO, Seq
from Bio.SeqUtils import nt_search
import numpy as np

# Load the sequences from a FASTA file
alignment = AlignIO.read("KCNA1_aves_mammals.fas", "fasta")

# Find positions of gaps in each sequence
gap_positions = {}
for record in alignment:
    gap_positions[record.id] = [i for i, base in enumerate(record.seq) if base == "-"]

# Translate sequences to amino acids, keeping gaps
translated_seqs = {}
for record in alignment:
    translated_seq = Seq.translate(record.seq, stop_symbol="*")
    translated_seqs[record.id] = Seq.Seq("")
    for i, base in enumerate(record.seq):
        if i in gap_positions[record.id]:
            translated_seqs[record.id] += "-"
        else:
            translated_seqs[record.id] += translated_seq[i // 3]

# Reverse translate amino acid sequences, skipping stop codons
reverse_translated_seqs = {}
for record_id, aa_seq in translated_seqs.items():
    aa_seq = aa_seq[:-1] if aa_seq.endswith("*") else aa_seq
    nt_seq = Seq.Seq("")
    aa_idx = 0
    for i in range(len(record.seq)):
        if i in gap_positions[record_id]:
            nt_seq += "---"  # Preserve gaps
        else:
            codon = record.seq[i:i + 3]
            if aa_idx < len(aa_seq) and aa_seq[aa_idx] != "*":
                nt_seq += codon
                aa_idx += 1
            else:
                nt_seq += "---"  # Skip stop codons

    reverse_translated_seqs[record_id] = nt_seq

# Calculate the transition to transversion ratio
def calculate_transition_transversion_ratio(seq1, seq2):
    transitions = ["AG", "GA", "CT", "TC"]
    transversions = ["AC", "CA", "GT", "TG", "AT", "TA", "GC", "CG"]

    ts_count = 0
    tv_count = 0

    for i in range(len(seq1)):
        if seq1[i] != "-" and seq2[i] != "-":
            pair = seq1[i] + seq2[i]
            if pair in transitions:
                ts_count += 1
            elif pair in transversions:
                tv_count += 1

    if tv_count == 0:
        return float("inf")
    else:
        return ts_count / tv_count

record_ids = list(reverse_translated_seqs.keys())
tt_ratios = np.zeros((len(record_ids), len(record_ids)))

for i in range(len(record_ids)):
    for j in range(i + 1, len(record_ids)):
        seq1 = reverse_translated_seqs[record_ids[i]]
        seq2 = reverse_translated_seqs[record_ids[j]]
        tt_ratio = calculate_transition_transversion_ratio(seq1, seq2)
        tt_ratios[i, j] = tt_ratio
        tt_ratios[j, i] = tt_ratio

# Print translated and reverse-translated sequences
for record_id, nt_seq in reverse_translated_seqs.items():
    print(f"ID: {record_id}\nTranslated AA Seq: {translated_seqs[record_id]}\nReverse-Translated NT Seq: {nt_seq}\n")

# Print transition to transversion ratios
print("Transition to Transversion Ratios:")
for i in range(len(record_ids)):
    for j in range(i + 1, len(record_ids)):
        print(f"{record_ids[i]} vs {record_ids[j]}: {tt_ratios[i, j]:.2f}")

# Read sequences from a FASTA file
def read_fasta(file_path):
    sequences = {}
    with open(file_path, "r") as fasta_file:
        lines = fasta_file.readlines()
        sequence_id = ""
        sequence = ""
        for line in lines:
            if line.startswith(">"):
                if sequence_id:
                    sequences[sequence_id] = sequence
                sequence_id = line.strip()[1:]
                sequence = ""
            else:
                sequence += line.strip()
        if sequence_id:
            sequences[sequence_id] = sequence
    return sequences

# Perform multiple sequence alignment as codons
def align_sequences_as_codons(sequences):
    aligned_sequences = {}
    for seq_id, sequence in sequences.items():
        # Split the sequence into codons
        codons = [sequence[i:i+3] for i in range(0, len(sequence), 3)]
        aligned_sequences[seq_id] = codons
    return aligned_sequences

# Translate codon sequences into amino acids
def translate_codons_to_aa(codon_sequences):
    aa_sequences = {}
    for seq_id, codons in codon_sequences.items():
        aa_sequence = "".join([codon_to_aa.get(codon, "-") for codon in codons])
        aa_sequences[seq_id] = aa_sequence
    return aa_sequences

# Reverse translate amino acid sequences to codon sequences
def reverse_translate_aa_to_codons(aa_sequences, original_sequences):
    codon_sequences = {}
    for seq_id, aa_sequence in aa_sequences.items():
        codon_sequence = ""
        orig_sequence = original_sequences[seq_id]
        orig_index = 0
        for aa in aa_sequence:
            if aa == "-":
                codon_sequence += "---"  # Preserve gaps
            else:
                codon_sequence += orig_sequence[orig_index:orig_index + 3]
                orig_index += 3
        codon_sequences[seq_id] = codon_sequence
    return codon_sequences

# Calculate the transition to transversion ratio
def calculate_transition_transversion_ratio(seq1, seq2):
    transitions = ["AG", "GA", "CT", "TC"]
    transversions = ["AC", "CA", "GT", "TG", "AT", "TA", "GC", "CG"]

    ts_count = 0
    tv_count = 0

    for i in range(len(seq1)):
        if seq1[i] != "-" and seq2[i] != "-":
            pair = seq1[i] + seq2[i]
            if pair in transitions:
                ts_count += 1
            elif pair in transversions:
                tv_count += 1

    if tv_count == 0:
        return float("inf")
    else:
        return ts_count / tv_count

# Read sequences from the FASTA file
sequences = read_fasta("/content/KCNA_mammals_fish.fas")

# Define the codon to amino acid mapping (standard genetic code)
codon_to_aa = {
    "TTT": "F", "TTC": "F", "TTA": "L", "TTG": "L",
    "TCT": "S", "TCC": "S", "TCA": "S", "TCG": "S",
    "TAT": "Y", "TAC": "Y", "TAA": "*", "TAG": "*",
    "TGT": "C", "TGC": "C", "TGA": "*", "TGG": "W",
    "CTT": "L", "CTC": "L", "CTA": "L", "CTG": "L",
    "CCT": "P", "CCC": "P", "CCA": "P", "CCG": "P",
    "CAT": "H", "CAC": "H", "CAA": "Q", "CAG": "Q",
    "CGT": "R", "CGC": "R", "CGA": "R", "CGG": "R",
    "ATT": "I", "ATC": "I", "ATA": "I", "ATG": "M",
    "ACT": "T", "ACC": "T", "ACA": "T", "ACG": "T",
    "AAT": "N", "AAC": "N", "AAA": "K", "AAG": "K",
    "AGT": "S", "AGC": "S", "AGA": "R", "AGG": "R",
    "GTT": "V", "GTC": "V", "GTA": "V", "GTG": "V",
    "GCT": "A", "GCC": "A", "GCA": "A", "GCG": "A",
    "GAT": "D", "GAC": "D", "GAA": "E", "GAG": "E",
    "GGT": "G", "GGC": "G", "GGA": "G", "GGG": "G"
}

# Perform multiple sequence alignment as codons
codon_sequences = align_sequences_as_codons(sequences)

# Translate codon sequences into amino acids
aa_sequences = translate_codons_to_aa(codon_sequences)

# Reverse translate amino acid sequences to codon sequences
reverse_translated_codons = reverse_translate_aa_to_codons(aa_sequences, sequences)

# Print translated and reverse-translated sequences
for seq_id, aa_seq in aa_sequences.items():
    print(f"ID: {seq_id}\nTranslated AA Seq: {aa_seq}\nReverse-Translated Codon Seq: {reverse_translated_codons[seq_id]}\n")

# Calculate transition to transversion ratios
record_ids = list(sequences.keys())
tt_ratios = {}

for i in range(len(record_ids)):
    for j in range(i + 1, len(record_ids)):
        seq1 = reverse_translated_codons[record_ids[i]]
        seq2 = reverse_translated_codons[record_ids[j]]
        tt_ratio = calculate_transition_transversion_ratio(seq1, seq2)
        tt_ratios[f"{record_ids[i]} vs {record_ids[j]}"] = tt_ratio

# Print transition to transversion ratios
print("Transition to Transversion Ratios:")
for pair, ratio in tt_ratios.items():
    print(f"{pair}: {ratio:.2f}")

# Define the standard codon table
codon_table = {
    "TTT": "F", "TTC": "F", "TTA": "L", "TTG": "L",
    "TCT": "S", "TCC": "S", "TCA": "S", "TCG": "S",
    "TAT": "Y", "TAC": "Y", "TAA": "*", "TAG": "*",
    "TGT": "C", "TGC": "C", "TGA": "*", "TGG": "W",
    "CTT": "L", "CTC": "L", "CTA": "L", "CTG": "L",
    "CCT": "P", "CCC": "P", "CCA": "P", "CCG": "P",
    "CAT": "H", "CAC": "H", "CAA": "Q", "CAG": "Q",
    "CGT": "R", "CGC": "R", "CGA": "R", "CGG": "R",
    "ATT": "I", "ATC": "I", "ATA": "I", "ATG": "M",
    "ACT": "T", "ACC": "T", "ACA": "T", "ACG": "T",
    "AAT": "N", "AAC": "N", "AAA": "K", "AAG": "K",
    "AGT": "S", "AGC": "S", "AGA": "R", "AGG": "R",
    "GTT": "V", "GTC": "V", "GTA": "V", "GTG": "V",
    "GCT": "A", "GCC": "A", "GCA": "A", "GCG": "A",
    "GAT": "D", "GAC": "D", "GAA": "E", "GAG": "E",
    "GGT": "G", "GGC": "G", "GGA": "G", "GGG": "G"
}

# Read sequences from the FASTA file
def read_fasta(file_path):
    sequences = {}
    with open(file_path, "r") as fasta_file:
        lines = fasta_file.readlines()
        sequence_id = ""
        sequence = ""
        for line in lines:
            if line.startswith(">"):
                if sequence_id:
                    sequences[sequence_id] = sequence
                sequence_id = line.strip()[1:]
                sequence = ""
            else:
                sequence += line.strip()
        if sequence_id:
            sequences[sequence_id] = sequence
    return sequences

# Perform multiple sequence alignment as codons
def align_sequences_as_codons(sequences):
    aligned_sequences = {}
    for seq_id, sequence in sequences.items():
        codons = [sequence[i:i+3] for i in range(0, len(sequence), 3)]
        aligned_sequences[seq_id] = codons
    return aligned_sequences

# Find positions of gaps in each sequence
def find_gap_positions(codon_sequences):
    gap_positions = {}
    for seq_id, codons in codon_sequences.items():
        gap_positions[seq_id] = [i for i, codon in enumerate(codons) if codon == '---']
    return gap_positions

# Translate codon sequences into amino acids
def translate_codons_to_aa(codon_sequences):
    aa_sequences = {}
    for seq_id, codons in codon_sequences.items():
        aa_sequence = "".join([codon_table.get(codon, '-') for codon in codons])
        aa_sequences[seq_id] = aa_sequence
    return aa_sequences

# Reverse translate amino acid sequences to codon sequences, skipping stop codons
def reverse_translate_aa_to_codons(aa_sequences, original_sequences):
    codon_sequences = {}
    for seq_id, aa_sequence in aa_sequences.items():
        codon_sequence = ""
        orig_sequence = original_sequences[seq_id]
        orig_index = 0
        for aa in aa_sequence:
            if aa == "-":
                codon_sequence += "---"  # Preserve gaps
            else:
                codon = orig_sequence[orig_index:orig_index + 3]
                orig_index += 3
                if codon_table.get(codon) != "*":
                    codon_sequence += codon
                else:
                    break  # Skip stop codons
        codon_sequences[seq_id] = codon_sequence
    return codon_sequences

# Calculate the transition to transversion ratio
# Calculate transition to transversion ratio
def calculate_transition_transversion_ratio(seq1, seq2):
    transitions = ["AG", "GA", "CT", "TC"]
    transversions = ["AC", "CA", "GT", "TG", "AT", "TA", "GC", "CG"]

    ts_count = 0
    tv_count = 0

    min_len = min(len(seq1), len(seq2))

    for i in range(min_len):
        if seq1[i] != "-" and seq2[i] != "-":
            pair = seq1[i] + seq2[i]
            if pair in transitions:
                ts_count += 1
            elif pair in transversions:
                tv_count += 1

    if tv_count == 0:
        return float("inf")
    else:
        return ts_count / tv_count


# Read sequences from the FASTA file
sequences = read_fasta("/content/KCNA1_aves_mammals.fas")

# Perform multiple sequence alignment as codons
codon_sequences = align_sequences_as_codons(sequences)

# Find positions of gaps in each sequence
gap_positions = find_gap_positions(codon_sequences)

# Translate codon sequences into amino acids
aa_sequences = translate_codons_to_aa(codon_sequences)

# Reverse translate amino acid sequences to codon sequences, skipping stop codons
reverse_translated_codons = reverse_translate_aa_to_codons(aa_sequences, sequences)

# Print translated and reverse-translated sequences
for seq_id, aa_seq in aa_sequences.items():
    print(f"ID: {seq_id}\nTranslated AA Seq: {aa_seq}\nReverse-Translated Codon Seq: {reverse_translated_codons[seq_id]}\n")

# Calculate transition to transversion ratios
record_ids = list(sequences.keys())
tt_ratios = {}

for i in range(len(record_ids)):
    for j in range(i + 1, len(record_ids)):
        seq1 = reverse_translated_codons[record_ids[i]]
        seq2 = reverse_translated_codons[record_ids[j]]
        tt_ratio = calculate_transition_transversion_ratio(seq1, seq2)
        tt_ratios[f"{record_ids[i]} vs {record_ids[j]}"] = tt_ratio

# Print transition to transversion ratios
print("Transition to Transversion Ratios:")
for pair, ratio in tt_ratios.items():
    print(f"{pair}: {ratio:.2f}")

sequences = {}
header = None

with open('/content/KCNA_mammals_fish.fas', 'r') as file:
    for line in file:
        line = line.rstrip()
        if line.startswith('>'):
            header = line[1:]
            sequences[header] = []
        else:
            sequences[header].append(line)

sequences = {key: ''.join(value) for key, value in sequences.items()}


def divide_into_codons(sequence):
    return [sequence[i:i+3] for i in range(0, len(sequence), 3)]


gaps = {key: [i for i, c in enumerate(value) if c == '-'] for key, value in sequences.items()}


codon_table = {
  'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
  'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
  'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
  'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
  'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
  'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
  'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
  'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
  'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
  'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
  'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
  'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
  'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
  'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
  'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
  'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
}


def translate(sequence):
    codons = divide_into_codons(sequence)
    return ''.join([codon_table[codon] for codon in codons if codon in codon_table])


reverse_codon_table = {v: k for k, v in codon_table.items() if v != '_'}


def reverse_translate(sequence):
    codons = divide_into_codons(sequence)
    return ''.join([reverse_codon_table[codon] for codon in codons if codon in reverse_codon_table])


def trans_ratio(seq1, seq2):
    trans_count = 0
    transv_count = 0
    purines = 'AG'
    pyrimidines = 'CT'

    for i, j in zip(seq1, seq2):
        if i != j:
            if (i in purines and j in purines) or (i in pyrimidines and j in pyrimidines):
                trans_count += 1
            else:
                transv_count += 1
    if transv_count == 0:
      return float("inf")
    else:
      return trans_count / transv_count


for seqname1, seq1 in sequences.items():
    for seqname2, seq2 in sequences.items():
        if seqname1 != seqname2:
            print(f'{seqname1} to {seqname2}: {trans_ratio(seq1, seq2)}')

reverse_codon_table = {v: k for k, v in codon_table.items() if v != '_'}

def translate(sequence):
    codons = divide_into_codons(sequence)
    return ''.join([codon_table[codon] if codon in codon_table else codon for codon in codons])

def reverse_translate(sequence):
    codons = divide_into_codons(sequence)
    return ''.join([reverse_codon_table[codon] if codon in reverse_codon_table else codon for codon in codons])


for key, value in sequences.items():
    amino_acid_sequence = translate(value)
    print(f'{key}: {amino_acid_sequence}')

for key, value in sequences.items():
    nucleotide_sequence = reverse_translate(value)
    print(f'{key}: {nucleotide_sequence}')

codon_table = {
  'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
  'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
  'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
  'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
  'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
  'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
  'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
  'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
  'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
  'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
  'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
  'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
  'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
  'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
  'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
  'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
}

seq1 = input();
seq2 = input();

if(seq1 == seq2):
  print("Equal")
else:
  print("Not")

sequences = {}
header = None

with open('/content/multiple_allignment_sequences.fas', 'r') as file:
    for line in file:
        line = line.rstrip()
        if line.startswith('>'):
            header = line[1:]
            sequences[header] = []
        else:
            sequences[header].append(line)

sequences = {key: ''.join(value) for key, value in sequences.items()}


def divide_into_codons(sequence):
    return [sequence[i:i+3] for i in range(0, len(sequence), 3)]


# Collect index positions where there's a gap in the sequence
gaps = {key: [i for i, c in enumerate(value) if c == '-'] for key, value in sequences.items()}

# Print gaps' array for each sequence
for seq_name, gap_array in gaps.items():
    print(f'Gaps for sequence {seq_name}: {gap_array}')


# same codon_table as before
codon_table = {
  'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
  'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
  'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
  'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
  'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
  'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
  'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
  'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
  'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
  'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
  'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
  'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
  'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
  'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
  'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
  'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
}

reverse_codon_table = {v: k for k, v in codon_table.items()}



def translate(sequence):
    codons = divide_into_codons(sequence)
    return ''.join([codon if '-' in codon else codon_table.get(codon, '') for codon in codons])


stop_codons = ['TAA', 'TAG', 'TGA']

def reverse_translate(sequence):
    amino_acids = divide_into_codons(sequence)
    return ''.join([aa if '-' in aa else reverse_codon_table.get(aa, '') for aa in amino_acids if aa not in stop_codons])


trans_count_sum = 0
transv_count_sum = 0

def trans_ratio(seq1, seq2):
    global trans_count_sum, transv_count_sum
    trans_count = 0
    transv_count = 0
    purines = 'AG'
    pyrimidines = 'CT'

    for i, j in zip(seq1, seq2):
        if i != j and '-' not in (i, j):  # consider only non-gap positions
            if (i in purines and j in purines) or (i in pyrimidines and j in pyrimidines):
                trans_count += 1
            else:
                transv_count += 1

    trans_count_sum += trans_count
    transv_count_sum += transv_count

    return trans_count / transv_count if transv_count != 0 else float('inf')


for seqname1, seq1 in sequences.items():
    for seqname2, seq2 in sequences.items():
        if seqname1 != seqname2:
            print(f'Transition/Transversion ratio from {seqname1} to {seqname2}: {trans_ratio(seq1, seq2)}')

print(f'Total Transition/Transversion ratio: {trans_count_sum / transv_count_sum if transv_count_sum != 0 else float("inf")}')

for seq_name, gap_array in gaps.items():
    print(f'Gaps for sequence {seq_name}: {gap_array}')

for key, value in sequences.items():
    amino_acid_sequence = translate(value)
    print(f'{key}: {amino_acid_sequence}')

reverse_codon_table = {v: k for k, v in codon_table.items()}
def reverse_translate(sequence):
    amino_acids = divide_into_codons(sequence)
    return ''.join([aa if '-' in aa else reverse_codon_table.get(aa, '') for aa in amino_acids if aa not in stop_codons])

for key, value in sequences.items():
    nucleotide_sequence = reverse_translate(value)
    print(f'{key}: {nucleotide_sequence}')

import os

# Define the standard genetic code
genetic_code = {
    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',
    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',
    'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',
    'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',
    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',
    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',
    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',
    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',
    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',
    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',
    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',
    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',
    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',
    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',
    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',
    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',
}

# Read the input sequences in FASTA format
def read_fasta(file_path):
    sequences = {}
    current_seq_id = None
    current_seq = []

    with open(file_path, 'r') as file:
        for line in file:
            line = line.strip()
            if line.startswith('>'):
                if current_seq_id is not None:
                    sequences[current_seq_id] = ''.join(current_seq)
                current_seq_id = line[1:]
                current_seq = []
            else:
                current_seq.append(line)

        if current_seq_id is not None:
            sequences[current_seq_id] = ''.join(current_seq)

    return sequences

# Perform multiple sequence alignment as codons
def perform_codon_alignment(sequences):
    aligned_sequences = {}
    gap_positions = {}

    # Find the maximum sequence length
    max_length = max(len(seq) for seq in sequences.values())

    # Pad sequences with gaps if needed
    for seq_id, sequence in sequences.items():
        if len(sequence) < max_length:
            sequences[seq_id] += '-' * (max_length - len(sequence))

    # Align sequences as codons
    for i in range(0, max_length, 3):
        codon_column = {seq_id: sequence[i:i + 3] for seq_id, sequence in sequences.items()}
        consensus_codon = "".join(codon_column.values())

        for seq_id, codon in codon_column.items():
            if codon != consensus_codon:
                if seq_id not in gap_positions:
                    gap_positions[seq_id] = []
                gap_positions[seq_id].append(i // 3)

    # Create aligned sequences
    for seq_id, sequence in sequences.items():
        aligned_sequence = " ".join([sequence[i:i + 3] for i in range(0, max_length, 3)])
        aligned_sequences[seq_id] = aligned_sequence

    return aligned_sequences, gap_positions

# Specify the path to your FASTA file
file_path = '/content/multiple_allignment_sequences.fas'

all_sequences = read_fasta(file_path)
aligned_sequences, gap_positions = perform_codon_alignment(all_sequences)

print("Aligned Sequences:")
for seq_id, aligned_seq in aligned_sequences.items():
    print(f'{seq_id}: {aligned_seq}')

print("\nGap Positions:")
for seq_id, gaps in gap_positions.items():
    print(f'{seq_id}: {gaps}')

codon_table = {
  'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
  'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
  'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
  'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
  'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
  'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
  'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
  'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
  'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
  'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
  'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
  'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
  'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
  'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
  'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
  'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
}

reverse_codon_table = {v: k for k, v in codon_table.items()}

def divide_into_codons(sequence):
    return [sequence[i:i+3] for i in range(0, len(sequence), 3)]

def translate(sequence):
  for seq_id, aligned_seq in aligned_sequences.items():
    codons = divide_into_codons(sequence)
    return ''.join([codon if '-' in codon else codon_table.get(codon, '') for codon in codons])

for key, value in aligned_sequences.items():
    amino_acid_sequence = translate(value)
    print(f'{key}: {amino_acid_sequence}')

stop_codons = ['TAA', 'TAG', 'TGA']
reverse_codon_table = {v: k for k, v in codon_table.items()}
def reverse_translate(sequence):
    amino_acids = divide_into_codons(sequence)
    return ''.join([aa if '-' in aa else reverse_codon_table.get(aa, '') for aa in amino_acids if aa not in stop_codons])

for key, value in aligned_sequences.items():
    nucleotide_sequence = reverse_translate(value)
    print(f'{key}: {nucleotide_sequence}')

#Working Code for codons

# Read the input sequences in FASTA format
def read_fasta(file_path):
    sequences = {}
    current_seq_id = None
    current_seq = []

    with open(file_path, 'r') as file:
        for line in file:
            line = line.strip()
            if line.startswith('>'):
                if current_seq_id is not None:
                    sequences[current_seq_id] = ''.join(current_seq)
                current_seq_id = line[1:]
                current_seq = []
            else:
                current_seq.append(line)

        if current_seq_id is not None:
            sequences[current_seq_id] = ''.join(current_seq)

    return sequences

# Perform multiple sequence alignment as codons
def perform_codon_alignment(sequences):
    aligned_sequences = {}
    gap_positions = {}

    # Find the maximum sequence length
    max_length = max(len(seq) for seq in sequences.values())

    # Pad sequences with gaps if needed
    for seq_id, sequence in sequences.items():
        if len(sequence) < max_length:
            sequences[seq_id] += '-' * (max_length - len(sequence))

    # Align sequences as codons
    for i in range(0, max_length, 3):
        codon_column = {seq_id: sequence[i:i + 3] for seq_id, sequence in sequences.items()}
        consensus_codon = "".join(codon_column.values())

        for seq_id, codon in codon_column.items():
            if codon != consensus_codon:
                if seq_id not in gap_positions:
                    gap_positions[seq_id] = []
                gap_positions[seq_id].append(i // 3)

    # Create aligned sequences
    for seq_id, sequence in sequences.items():
        aligned_sequence = " ".join([sequence[i:i + 3] for i in range(0, max_length, 3)])
        aligned_sequences[seq_id] = aligned_sequence

    return aligned_sequences, gap_positions

# Specify the path to your FASTA file
file_path = '/content/multiple_allignment_sequences.fas'

all_sequences = read_fasta(file_path)
aligned_sequences, gap_positions = perform_codon_alignment(all_sequences)

print("Aligned Sequences:")
for seq_id, aligned_seq in aligned_sequences.items():
    print(f'{seq_id}: {aligned_seq}')

print("\nGap Positions:")
for seq_id, gaps in gap_positions.items():
    print(f'{seq_id}: {gaps}')



codon_table = {
  'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
  'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
  'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
  'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
  'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
  'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
  'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
  'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
  'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
  'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
  'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
  'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
  'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
  'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
  'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
  'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
}

reverse_codon_table = {v: k for k, v in codon_table.items()}

def divide_into_codons(sequence):
    return [sequence[i:i+3] for i in range(0, len(sequence), 3)]

def translate(sequence):
  for seq_id, aligned_seq in aligned_sequences.items():
    codons = divide_into_codons(sequence)
    return ''.join([codon if '-' in codon else codon_table.get(codon, '') for codon in codons])

stop_codons = ['TAA', 'TAG', 'TGA']
reverse_codon_table = {v: k for k, v in codon_table.items()}
def reverse_translate(sequence):
  for seq_id, aligned_seq in aligned_sequences.items():
    amino_acids = divide_into_codons(sequence)
    return ''.join([aa if '-' in aa else reverse_codon_table.get(aa, '') for aa in amino_acids if aa not in stop_codons])



trans_count_sum = 0
transv_count_sum = 0

def trans_ratio(seq1, seq2):
    global trans_count_sum, transv_count_sum
    trans_count = 0
    transv_count = 0
    purines = 'AG'
    pyrimidines = 'CT'

    for i, j in zip(seq1, seq2):
        if i != j and '-' not in (i, j):  # consider only non-gap positions
            if (i in purines and j in purines) or (i in pyrimidines and j in pyrimidines):
                trans_count += 1
            else:
                transv_count += 1

    trans_count_sum += trans_count
    transv_count_sum += transv_count

    return trans_count / transv_count if transv_count != 0 else float('inf')


for seqname1, seq1 in aligned_sequences.items():
    for seqname2, seq2 in aligned_sequences.items():
        if seqname1 != seqname2:
            print(f'Transition/Transversion ratio from {seqname1} to {seqname2}: {trans_ratio(seq1, seq2)}')

print(f'Total Transition/Transversion ratio: {trans_count_sum / transv_count_sum if transv_count_sum != 0 else float("inf")}')


#Amino acid conversion
print("\nAmino Acid Sequences:")
for key, value in aligned_sequences.items():
    amino_acid_sequence = translate(value)
    print(f'{key}: {amino_acid_sequence}')

#Amino acid to nucleotide conversion
print("\nNucleotide Sequences:")
for key, value in aligned_sequences.items():
    nucleotide_sequence = reverse_translate(value)
    print(f'{key}: {nucleotide_sequence}')

# Define the keyword you want to exclude
keyword_to_exclude = "PREDICTED"

# Initialize a list to store sequences to be printed
sequences_to_print = []

# Open the FASTA file for reading
with open("P02768SimilarSeq.fas", "r") as fasta_file:
    current_sequence = ""
    current_header = ""

    # Loop through each line in the file
    for line in fasta_file:
        if line.startswith(">"):
            # If a new header line is encountered, check if it contains the keyword
            current_header = line.strip()
            if keyword_to_exclude not in current_header:
                # If the keyword is not in the header, add the previous sequence to the list
                sequences_to_print.append(current_header)
                sequences_to_print.append(current_sequence)
            # Reset the current_sequence for the new sequence
            current_sequence = ""
        else:
            # Append the sequence lines
            current_sequence += line.strip()

# Print the sequences without the excluded keyword
for sequence in sequences_to_print:
    print(sequence)

pip install Bio

from Bio import SeqIO

# Replace 'your_file.fasta' with the path to your FASTA file
input_file = 'TejThakar_AU2040262_Bioinfo quiz.fas'
output_file = 'TejThakar_AU2040262_Bioinfo quiz_100.fas'

# Open the output file for writing
with open(output_file, 'w') as out_handle:
    # Open the input FASTA file for reading
    with open(input_file, 'r') as in_handle:
        records = list(SeqIO.parse(in_handle, 'fasta'))

        # Take the first 100 sequences or fewer if the file has fewer than 100 sequences
        selected_records = records[:100]

        # Write the selected records to the output file
        SeqIO.write(selected_records, out_handle, 'fasta')

print(f'First 100 sequences have been saved to {output_file}')

#Distance Matrix
matrix = [
    ['-', 'A', 'B', 'C', 'D', 'E'],
    ['B', '5'],
    ['C', '4', '7'],
    ['D', '7', '10', '7'],
    ['E', '6', '9', '6', '5'],
    ['F', '8', '11', '8', '9', '8']]

pip install biopython

from Bio.Seq import Seq

import Bio
print(Bio.__version__)

# from Bio.Alphabet.IUPAC import unambiguous_dna

new_seq = Seq('GATCAGAAG')
new_seq[0:2]
print(new_seq[0:2])
new_seq.translate()

my_seq = Seq("AGTACACTGGT")
my_seq
# print(my_seq)

my_seq.complement()

my_seq.reverse_complement()

from Bio import SeqIO
for seq_record in SeqIO.parse('ls_orchid.fasta', 'fasta'):
  print(seq_record.id)
  print(repr(seq_record.seq))
  print(len(seq_record))

print('Total no. of Sequences', len(repr(seq_record.seq)))

for seq_record in SeqIO.parse("ls_orchid.gbk", "genbank"):
  print(seq_record.id)
  print(repr(seq_record.seq))
  print(len(seq_record))

# print(len(seq_record.id))

from Bio.Seq import Seq
my_seq = Seq("GATCG")
for index, letter in enumerate(my_seq):
  print("%i %s" % (index, letter))

print("Length: ", len(my_seq))

from Bio import SeqIO
print("Sequence ID\t Sequence")
for seq_record in SeqIO.parse("ls_orchid.gbk", "genbank"):
  print("%s\t %s" % (seq_record.id, seq_record.seq))

from Bio.Seq import Seq
Seq("AATCGAATAACGTA").count("AA")

pip install biopython

from Bio import SeqIO

# Step 1: Parse the GenBank file to extract the DNA sequence
def extract_sequence_from_genbank(genbank_file):
    for record in SeqIO.parse(genbank_file, "genbank"):
        return str(record.seq)

# Step 2: Define a function to find palindromic substrings
def find_palindromic_substrings(sequence):
    palindromic_substrings = {}
    sequence = sequence.upper()

    for length in range(2, len(sequence) + 1):
        for i in range(len(sequence) - length + 1):
            substring = sequence[i:i+length]
            if substring == substring[::-1]:
                palindromic_substrings[substring] = i

    return palindromic_substrings

# Step 3: Create a dictionary of palindromic substrings and their positions
genbank_file = "ls_orchid.gbk"
sequence = extract_sequence_from_genbank(genbank_file)
palindromic_substrings = find_palindromic_substrings(sequence)

# Print the dictionary of palindromic substrings and their positions
for substring, position in palindromic_substrings.items():
    print(f"Palindromic Substring: {substring}, Position: {position}")

from Bio import SeqIO

def extract_from_genfile(genebank_file):
  for seq_record in SeqIO.parse(genebank_file, "genbank"):
    return str(seq_record.seq)

def check_palindrome_sequence(seq):
  pal_sub = {}
  # seq = seq.upper()

  for length in range(2, len(seq)+1):
    for i in range(len(seq) - length + 1):
      substring = seq[i:i+length]
      if substring == substring[::-1]:
        pal_sub[substring] = i

  return pal_sub


file_gene = "ls_orchid.gbk"

sequence = extract_from_genfile(file_gene)

palindrome_substring = check_palindrome_sequence(sequence)

for sub, pos in palindrome_substring.items():
  print(f"Palindromic Substring: {sub}, Position: {pos}")

pip install biopython

from Bio.Data import CodonTable
standard_table = CodonTable.unambiguous_dna_by_name["Standard"]
mito_table = CodonTable.unambiguous_dna_by_name["Vertebrate Mitochondrial"]

print(standard_table)

print(mito_table)

mito_table.stop_codons

standard_table.stop_codons

mito_table.start_codons

standard_table.start_codons

plant_table = CodonTable.unambiguous_dna_by_name["Plant Plastid"]

print(plant_table)

plant_table.stop_codons

from Bio import SeqIO

sequence_dict = {}

for seq_record in SeqIO.parse("ls_orchid.fasta", "fasta"):
  sequence_dict[seq_record.id] = seq_record.seq

sequence_dict

with open('bio.txt', 'w') as bio_file:
  for key,value in sequence_dict.items():
    bio_file.write("%s:%s\n" % (key,value))

pip install biopython

from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Data import CodonTable
import os

# Get standard and plastid codon tables
standard_table = CodonTable.standard_dna_table
plastid_table = CodonTable.ambiguous_generic_by_id[11]  # Plastid codon table ID: 11

def translate_sequence(sequence, codon_table):
    translated_seq = []
    for i in range(0, len(sequence), 3):
        codon = sequence[i:i + 3]
        if len(codon) == 3 and 'N' not in codon:
            amino_acid = codon_table.forward_table.get(codon, "X")
            translated_seq.append(amino_acid)
    return "".join(translated_seq)

# Read input sequences from the FASTA file
input_file = "ls_orchid.fasta"
output_file = "bio.fasta"


with open(output_file, "w") as combined_output:
    for record in SeqIO.parse(input_file, "fasta"):
        standard_translation = translate_sequence(str(record.seq), standard_table)
        plastid_translation = translate_sequence(str(record.seq), plastid_table)

        # Create SeqRecord objects for translated sequences
        standard_seq_record = SeqRecord(Seq(standard_translation), id=f"{record.id}_standard", description="Standard Codon Translation")
        plastid_seq_record = SeqRecord(Seq(plastid_translation), id=f"{record.id}_plastid", description="Plastid Codon Translation")

        # Write translated sequences to the combined output file
        SeqIO.write(standard_seq_record, combined_output, "fasta")
        SeqIO.write(plastid_seq_record, combined_output, "fasta")

from Bio import SeqIO

standard_translation_file = open('ls_orchid_standard.fasta', 'w')
plastid_translation_file = open('ls_orchid_plastid.fasta', 'w')

for seq_record in SeqIO.parse('ls_orchid.fasta', 'fasta'):
    standard_translation_file.write(str(f'>{seq_record.description}\n'))
    plastid_translation_file.write(str(f'>{seq_record.description}\n'))

    standard_translation_file.write(f'{seq_record.translate().seq}\n\n')
    plastid_translation_file.write(f'{seq_record.translate(table=2).seq}\n\n')


    individual_file = open(f'{seq_record.id[3:10]}.fasta', 'w')
    individual_file.write(str(f'>{seq_record.description}(standard)\n'))
    individual_file.write(f'{seq_record.translate().seq}\n\n')

    individual_file.write(f'>{seq_record.description}(plastid)\n')
    individual_file.write(f'{seq_record.translate(table=2).seq}\n\n')

    individual_file.close()

standard_translation_file.close()
plastid_translation_file.close()

# TAA -> TGA
# TAG -> TAA
# TGA -> TAA
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Data import CodonTable
from Bio.Seq import MutableSeq


for seq_record in SeqIO.parse('ls_orchid.fasta', 'fasta'):
  print(seq_record.id)
  print(MutableSeq(seq_record.seq))
  # print(repr(seq_record.seq))
  # print(len(seq_record))

  mut_seq = MutableSeq(seq_record.seq)


  if(mut_seq[len(mut_seq) - 3 : len(mut_seq)] == 'TAA'):
    mut_seq[len(mut_seq) - 3 : len(mut_seq)] = 'TGA'
  elif(mut_seq[len(mut_seq) - 3 : len(mut_seq)] == 'TAG'):
    mut_seq[len(mut_seq) - 3 : len(mut_seq)] = 'TAA'
  elif(mut_seq[len(mut_seq) - 3 : len(mut_seq)] == 'TGA'):
    mut_seq[len(mut_seq) - 3 : len(mut_seq)] = 'TAA'
  else:
    mut_seq = mut_seq

  print(seq_record.id)
  print(mut_seq)
  print(len(mut_seq))
  # print(MutableSeq(seq_record.seq))
  # print(repr(seq_record.seq))
  # print(len(seq_record))

from Bio import SeqIO
from Bio.Seq import Seq
from Bio import pairwise2

cnt = 0
standard_translation_file = open('ls_orchid_four.fasta', 'w')

for seq_record in SeqIO.parse('ls_orchid.fasta', 'fasta'):
  standard_translation_file.write(str(f'>{seq_record.description}\n'))
  standard_translation_file.write(f'{seq_record.translate().seq}\n\n')
  cnt+=1

  if(cnt>3):
    break


standard_translation_file.close()

from Bio import SeqIO
from Bio.Seq import Seq
from Bio import pairwise2


sequences = []

for seq_record in SeqIO.parse('ls_orchid_four.fasta', 'fasta'):
  sequences.append(seq_record.seq)

for i in range(2):
  for j in range(i+1, 3):
    alignment = pairwise2.align.globalxx(sequences[i], sequences[j])
    # print(alignment.seqA)
    # print(alignment.seqB)
    # print(alignment.score)
    # print(alignment.start)
    # print(alignment.end)
    # print(*alignment)
    print(pairwise2.format_alignment(*alignment[0]))

from Bio import SeqIO
from Bio.Seq import Seq
from Bio import pairwise2


sequences = []

standard_translation_file = open('ls_orchid_four_aligned.fasta', 'w')


for seq_record in SeqIO.parse('ls_orchid_four.fasta', 'fasta'):
  sequences.append(seq_record.seq)

for i in range(2):
  for j in range(i+1, 3):
    alignment = pairwise2.align.globalxx(sequences[i], sequences[j])

    standard_translation_file.write(str(f'First Sequence = {sequences[i]}\n'))
    standard_translation_file.write(str(f'Second Sequence = {sequences[j]}\n\n'))
    standard_translation_file.write(f'{pairwise2.format_alignment(*alignment[0])}\n\n')


standard_translation_file.close()

pip install biopython

# Choose 4 random sequences from the fasta file
import random
from Bio import SeqIO

# Specify the number of sequences you want to randomly select
num_sequences_to_select = 4

# Open the output file
standard_translation_file = open('ls_orchid_four.fasta', 'w')

# Read all sequences from the input file
all_sequences = list(SeqIO.parse('ls_orchid.fasta', 'fasta'))

# Randomly select a subset of sequences
selected_sequences = random.sample(all_sequences, min(num_sequences_to_select, len(all_sequences)))

# Write the selected sequences to the output file
for seq_record in selected_sequences:
    standard_translation_file.write(f'>{seq_record.description}\n')
    standard_translation_file.write(f'{seq_record.translate().seq}\n\n')

# Close the output file
standard_translation_file.close()